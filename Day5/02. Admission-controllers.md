# 🔹 What are **Admission Controllers** in Kubernetes?

**Admission Controllers** are **plugins in the Kubernetes API server** that intercept requests **after authentication/authorization** but **before objects are persisted in etcd**.

They can:

* ✅ **Validate** requests (accept/reject).
* ✅ **Mutate** requests (modify them before persistence).

![Uploading image.png…]()


---

## 🔹 Types of Admission Controllers

1. **Validating Admission Controllers**

   * Enforce policies by checking compliance.
   * Example: Prevent running privileged pods.

2. **Mutating Admission Controllers**

   * Can **modify objects** before they are stored.
   * Example: Automatically inject a sidecar container (e.g., Istio Envoy).

---

## 🔹 Example 1: Validation Error (Non-existent Namespace)

Create a Pod manifest in a non-existent namespace:

```bash
vim test-admission.yaml
```

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: admission-test
  namespace: notexist-ns   # 🚨 This namespace doesn't exist
spec:
  containers:
    - name: nginx
      image: nginx
```

Apply it:

```bash
kubectl apply -f test-admission.yaml
```

Expected error:

```
Error from server (Forbidden): error when creating "test-admission.yaml":
namespaces "notexist-ns" not found
```

---

## 🔹 Example 2: QoS Classes & LimitRanger

Kubernetes Admission Controllers help enforce **resource policies**.
The `LimitRanger` admission controller validates whether pods meet namespace resource constraints.

### Kubernetes QoS Classes:

* **Guaranteed** → `requests == limits` for all containers.
* **Burstable** → `requests < limits` (but requests set).
* **BestEffort** → No `requests` or `limits` set.

---

### Step 1: Create Burstable Pod

```bash
vim burstable-pod.yaml
```

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: burstable-test
spec:
  containers:
    - name: nginx
      image: nginx
      resources:
        requests:        # Minimum resources
          cpu: "100m"
          memory: "64Mi"
        limits:          # Maximum allowed
          cpu: "200m"
          memory: "128Mi"
```

Here: `requests < limits` → Pod is **Burstable**.

---

### Step 2: Apply Pod

```bash
kubectl apply -f burstable-pod.yaml
```

---

### Step 3: Verify QoS

```bash
kubectl get pod burstable-test -o=jsonpath='{.status.qosClass}'
```

Expected output:

```
Burstable
```

---

## 🔹 Example 3: LimitRanger Enforcement & Mutation

We’ll demonstrate **two namespaces**:

1. **Enforce-only** LimitRange → ❌ Rejects pods.
2. **Defaulting** LimitRange → ✅ Mutates pods with defaults.

---

### 🟢 Example 3.1: Enforce-only (Rejects Pod)

#### Step 1: Create namespace

```bash
kubectl create namespace enforce-demo
```

#### Step 2: Create LimitRange (min/max only)

```bash
vim enforce-lr.yaml
```

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: enforce-range
  namespace: enforce-demo
spec:
  limits:
    - min:
        memory: 128Mi
      max:
        memory: 512Mi
      type: Container
```

Apply:

```bash
kubectl apply -f enforce-lr.yaml
```

#### Step 3: Create pod without resources

```bash
vim enforce-pod.yaml
```

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: enforce-test
  namespace: enforce-demo
spec:
  containers:
    - name: nginx
      image: nginx
```

Apply:

```bash
kubectl apply -f enforce-pod.yaml
```

👉 **Expected Result**:

```
Error from server (Forbidden): Pod "enforce-test" is forbidden:
Minimum memory usage per Container is 128Mi, but no request is specified.
```

---

### 🟢 Example 3.2: Defaulting (Mutates Pod)

#### Step 1: Create namespace

```bash
kubectl create namespace default-demo
```

#### Step 2: Create LimitRange with defaults

```bash
vim default-lr.yaml
```

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: default-range
  namespace: default-demo
spec:
  limits:
    - default:
        memory: 256Mi
      defaultRequest:
        memory: 128Mi
      type: Container
```

Apply:

```bash
kubectl apply -f default-lr.yaml
```

#### Step 3: Create pod without resources

```bash
vim default-pod.yaml
```

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: default-test
  namespace: default-demo
spec:
  containers:
    - name: nginx
      image: nginx
```

Apply:

```bash
kubectl apply -f default-pod.yaml
```

👉 **Expected Result**: Pod is created ✅

Check assigned resources:

```bash
kubectl get pod default-test -n default-demo -o yaml | grep -A5 resources:
```

Output shows Admission Controller mutated the spec:

```yaml
resources:
  requests:
    memory: "128Mi"
  limits:
    memory: "256Mi"
```

---

## 🔹 Summary

* Admission Controllers run **between authentication and persistence**.
* **Validating controllers**: Reject requests if invalid.
* **Mutating controllers**: Modify requests before storing.
* **LimitRanger Admission Controller**:

  * Enforce-only → ❌ Rejects invalid pods.
  * Defaulting → ✅ Mutates pod with default values.

---


